<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Note | Rain-driven Development]]></title>
  <link href="http://boxingp.github.io/blog/categories/note/atom.xml" rel="self"/>
  <link href="http://boxingp.github.io/"/>
  <updated>2015-10-24T22:15:42+08:00</updated>
  <id>http://boxingp.github.io/</id>
  <author>
    <name><![CDATA[Boxing]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《敏捷软件开发：原则、模式与实践》读书笔记]]></title>
    <link href="http://boxingp.github.io/blog/2015/02/27/the-agile-software-development-reading-notes/"/>
    <updated>2015-02-27T22:05:42+08:00</updated>
    <id>http://boxingp.github.io/blog/2015/02/27/the-agile-software-development-reading-notes</id>
    <content type="html"><![CDATA[<p>发现自己对于Java的一些设计以及实践了解得不够，导致写出来的代码存在着问题，同时也想要和其他人很好地交流自己的设计思路。今天终于摸出了这本书，好好读一下，同时写代码实践，希望会有提高。</p>

<!-- more -->


<p>第二本Bob大叔的书。</p>

<h2>前言</h2>

<blockquote><p>敏捷开发（Agile Development）</p>

<p>极限编程（eXtreme Programming，简称XP）</p></blockquote>

<h1>第I部分 敏捷开发</h1>

<h2>第1章 敏捷实践</h2>

<p>概括出如何让软件开发团队具有快速工作、响应变化能力的价值观（value）。也就是敏捷联盟宣言。瞄了一眼名单，看到了Martin Fowler，<a href="http://martinfowler.com/">他的网站</a>有不少干货。</p>

<blockquote><ol>
<li><p>个体和交互胜过过程和工具</p></li>
<li><p>可以工作的软件胜过面面俱到的文档</p></li>
<li><p>客户合作胜过合同谈判</p></li>
<li><p>响应变化胜过遵循计划</p></li>
</ol>
</blockquote>

<p>于是引出了12条原则</p>

<blockquote><ol>
<li>我们最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意。</li>
</ol>
</blockquote>

<p>持续交付。</p>

<blockquote><ol>
<li>即使到了开发的后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势。</li>
</ol>
</blockquote>

<p>保持软件结构的灵活性。</p>

<blockquote><ol>
<li>经常性地交付可以工作的软件，交付的间隔可以从几周到几个月，交付的时间间隔越短越好。</li>
</ol>
</blockquote>

<p>快速迭代。</p>

<blockquote><ol>
<li><p>在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。</p></li>
<li><p>围绕被激励起来的个人来构建项目。给他们提供所需要的环境和支持，并且信任他们能够完成工作。</p></li>
<li><p>在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈。</p></li>
<li><p>工作的软件是首要的进度度量标准。</p></li>
</ol>
</blockquote>

<p>我的理解是要明确好真正的目标是什么。</p>

<blockquote><ol>
<li>敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度。</li>
</ol>
</blockquote>

<p>还是那句话，敏捷项目是马拉松长跑。</p>

<blockquote><ol>
<li><p>不断地关注优秀的技能和好的设计会增强敏捷能力。</p></li>
<li><p>简单——使未完成的工作最大化的艺术——是根本的。</p></li>
</ol>
</blockquote>

<p>我觉得TDD的好处就是可以避免开发的过程中想太多导致范围超出预期。</p>

<blockquote><ol>
<li>最好的构架、需求和设计出自于自组织的团队。</li>
</ol>
</blockquote>

<p>敏捷团队的成员共同来解决项目中所有方面的问题。</p>

<blockquote><ol>
<li>每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。</li>
</ol>
</blockquote>

<p>隔一段时间进行一下Retro。</p>

<h2>第2章 极限编程概述</h2>

<blockquote><p>极限编程（eXtreme Programming，简称XP）是敏捷方法中最著名的一个。它由一系列简单却互相依赖的实践组成。</p>

<p>1.客户作为团队成员</p>

<p>XP团队中的客户是指定义产品的特性并排列这些特性优先级的人或者团队。</p>

<p>2.用户素材</p>

<p>在XP中，我们和客户反复讨论，以获取对于需求细节的理解，但是不去捕获那些细节。</p>

<p>用户素材（user stories）就是正在进行的关于需求谈话的助记符。</p>

<p>3.短交付周期</p>

<p>3.1迭代计划</p>

<p>它由客户根据开发人员确定的预算而选择的一些用户素材组成。</p>

<p>3.2发布计划</p>

<p>它表示了一次较大的交付，通常此次交付会被加入到产品中。</p>

<p>4.验收测试</p>

<p>5.结对编程</p>

<p>6.测试驱动的开发方法</p>

<p>7.集体所有权</p>

<p>结对编程中的每一对都具有拆出（check out）任何模块并对它进行改进的权利。</p>

<p>8.持续集成</p>

<p>9.可持续的开发速度</p>

<p>10.开放的工作空间</p>

<p>11.计划游戏</p>

<p>计划游戏（planning game）的本质是划分业务人员和开发人员之间的职责。业务人员（也就是客户）决定特性（feature）的重要性，开发人员决定实现一个特性所花费的代价。</p>

<p>在每次发布和每次迭代的开始，开发人员基于在最近一次迭代或者最近一次发布中他们所完成的工作量，为客户提供一个预算。客户选择那些所需的成本合计起来不超过该预算的用户素材。</p>

<p>12.简单的设计</p>

<p>12.1考虑能够工作的最简单的事情</p>

<p>12.2你将不需要它</p>

<p>他们开始时假设将不需要那些基础结构。</p>

<p>12.3一次，并且只有一次</p>

<p>极限编程者不能容忍重复的代码。</p>

<p>13.重构</p>

<p>14.隐喻</p>

<p>它是将整个系统联系在一起的全局视图：它是系统的未来景象，是它使得所有单独模块的位置和外观（shape）变得明显直观。如果模块的外观与整个系统的隐喻不符，那么你就知道该模块是错误的。</p>

<p>隐喻通常可以归纳为一个名字系统。这些名字提供了一个系统组成元素的词汇表，并且有助于定义它们之间关系。</p></blockquote>

<h2>第3章 计划</h2>

<p>这章是对XP中计划游戏的描述。</p>

<blockquote><p>1.初始探索</p>

<p>在项目开始时，开发人员和客户会尽量确定出所有真正重要的用户素材。</p>

<p>素材的编写会一直持续到项目完成。</p>

<p>开发人员共同对这些素材进行估算。估算是相对的，不是绝对的。</p>

<p><strong>探究、分解和速度</strong></p>

<p>对一个用户素材进行分解或者合并的主要原因，是为了使其大小适于被准确地估算。</p>

<p>为了知道用户素材的绝对大小，需要一个称为速度（velocity）的因子。</p>

<p>通常，花费几天时间去原型化一到两个用户素材来了解团队的速度就足够了。这样的一个原型化过程称为探究（spike）。</p>

<p>2.发布计划</p>

<p>客户挑选在该发布中她们想要实现的素材，并大致确定这些素材的实现顺序。客户不能选择与当前开发速度不符的更多的素材。</p>

<p>3.迭代计划</p>

<p>4.任务计划</p>

<p>开发人员把素材分解成开发任务，一个任务就是一个开发人员能够在4～16小时之内实现的一些功能。</p>

<p><strong>迭代的中点</strong></p>

<p>在这个时间点上，本次迭代中所安排的半数素材应该被完成。如果没有完成，那么团队会设法重新分配没有完成的任务和职责，以保证在迭代结束时能够完成所有的素材。</p>

<p>5.迭代</p>

<p>每两周，本次迭代结束，下次迭代开始。在每次迭代结束时，会给客户演示当前可运行的程序。要求客户对项目程序的外观、感觉和性能进行评价。客户会以新的用户素材的方式提供反馈。</p></blockquote>

<h1>第4章 测试</h1>

<blockquote><p>1.测试驱动的开发方法。</p>

<p>程序中的每一项功能都有测试来验证它的操作的正确性。</p>

<p>首先编写测试可以迫使我们使用不同的观察点。</p>

<p>通过首先编写测试，我们就迫使自己把程序设计为可测试的。</p>

<p>首先编写测试的另一个重要效果，是测试可以作为一种无价的文档形式。</p>

<p>有意图的编程（intentional programming）。在实现之前，先在测试中陈述你的意图，使你的意图尽可能地简单、易读。你相信这种简单和清楚会给程序指出一个好的结构。</p>

<p>在编写产品代码之前，先编写测试常常会暴露程序中应该被解耦合的区域。¡¡</p>

<p>为了测试而对模块进行隔离的需要，迫使我们以对整个程序结构都有益的方式对程序进行解耦合。</p>

<p>2.验收测试</p>

<p>作为验证工具来说，单元测试是必要的，但是不够充分。单元测试用来验证系统的小的组成单元应该按照所期望的方式工作，但是它们没有验证系统作为一个整体时工作的正确性。单元测试是用来验证系统中个别机制的白盒测试（white-box tests）。验收测试是用来验证系统满足客户需求的黑盒测试（black-box tests）。</p>

<p>验收测试由不了解系统内部机制的人编写。客户可以直接或者和一些技术人员（可能是QA人员）一起来编写验收测试。验收测试是程序，因此是可以运行的。然而，通常使用专为应用程序的客户创建的脚本语言来编写验收测试。</p>

<p>验收测试是关于一项特性（feature）的最终的文档。</p>

<p>此外，首先编写验收测试的行为对于系统的构架方面具有深远的影响。</p>

<p>3.结论</p>

<p>测试套件运行起来越简单，就会越频繁地运行它们。测试运行得越多，就会越快地发现和那些测试的任何背离。</p>

<p>单元测试和验收测试都是一种文档形式，那样的文档是可以编译和执行的；因此，它是准确和可靠的。此外，编写测试所使用的语言是明确的，并且它们的观看者使这些语言非常易读。</p>

<p>测试最重要的好处就是它对于构架和设计的影响。</p></blockquote>

<h2>第5章 重构</h2>

<blockquote><p>在Martin Fowler的名著《重构》一书中，他把重构（Refactoring）定义为：“……在不改变代码外在行为的前提下对代码做出修改，以改进代码的内部结构的过程。”</p>

<p>每一个软件模块都具有三项职责。第一个职责是它运行起来所完成的功能。……第二个职责是它要应对变化。……第三个职责是要和阅读它的人进行沟通。</p>

<p>重构的目的，正像在本章中描述的，是为了每天清洁你的代码。</p></blockquote>

<h2>第6章 一次编程实践</h2>

<blockquote><p>图示有时是不需要的。何时不需要呢？在创建了它们而没有验证它们的代码就打算去遵循它们时，图示就是无意的。画一幅图来探究一个想法是没有错的。然而，画一幅图后，不应该假定该图就是相关任务的最好设计。你会发现最好的设计是在你首先编写测试，一小步一小步前进时逐渐形成的。</p></blockquote>

<p>形象地展现了结对编程、TDD以及重构的过程。</p>

<p>多一句嘴，之前一直在诺基亚手机上玩bowling的游戏，看完这章知道它的记分规则了。</p>

<h1>第II部分 敏捷设计</h1>

<blockquote><p>在每次迭代中，团队改进系统设计，使设计尽可能适合于当前系统。团队不会花费许多时间去预测未来的需求和需要，也不会试图在今天就构建一些基础结构去支撑那些他们认为明天才会需要的特性。他们更愿意关注当前的系统结构，并使它尽可能地好。</p>

<p><strong>拙劣设计的症状</strong></p>

<ul>
<li><p>僵化性（Rigidity）</p></li>
<li><p>脆弱性（Fragility）</p></li>
<li><p>牢固性（Immobility）</p></li>
<li><p>粘滞性（Viscosity）</p></li>
<li><p>不必要的复杂性（Needless Complexity）</p></li>
<li><p>不必要的重复（Needless Repetition）</p></li>
<li><p>晦涩性（Opacity）</p></li>
</ul>


<p><strong>原则</strong></p>

<ul>
<li><p>单一职责原则（The Single Responsibility Principle，简称SRP）</p></li>
<li><p>开放-封闭原则（The Open-Close Principle，简称OCP）</p></li>
<li><p>Liskov替换原则（The Liskov Substitution Principle，简称LSP）</p></li>
<li><p>依赖倒置原则（The Dependency Inversion Principle，简称DIP）</p></li>
<li><p>接口隔离原则（The Interface Segregation Principle，简称ISP）</p></li>
</ul>
</blockquote>

<p>这就是面向对象设计中所说的<a href="http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29">SOLID</a>。</p>

<h2>第7章 什么是敏捷设计</h2>

<blockquote><p>软件项目的设计是一个抽象的概念。它和程序的概括形状（shape）、结构以及每一个模块、类和方法的详细形状和结构有关。可以使用许多不同的媒介（media）去描绘它，但是它最终体现为源代码。最后，源代码就是设计。</p>

<p>当软件出现下面任何一种气味时，就表明软件正在腐化。</p>

<p>1.僵化性（Rigidity）</p>

<p>僵化性是指难以对软件进行改动，即使是简单的改动。如果单一的改动会导致有依赖关系的模块中的连锁改动，那么设计就是僵化的。必须要改动的模块越多，设计就越僵化。</p>

<p>2.脆弱性（Fragility）</p>

<p>脆弱性是指，在进行一个改动时，程序的许多地方就可能出现问题。</p>

<p>3.牢固性（Immobility）</p>

<p>牢固性是指，设计中包含了对其他系统有用的部分，但是要把这些部分从系统中分离出来所需要的努力和风险是巨大的。</p>

<p>4.粘滞性（Viscosity）</p>

<p>粘滞性有两种表现形式：软件的粘滞性和环境的粘滞性。</p>

<p>当面临一个改动时，开发人员常常发现会有多种改动的方法。其中，一些方法会保持设计：而另外一些会破坏设计（也就是生硬的手法）。当那些可以保持系统设计的方法比那些生硬手法更难应用时，就表明设计具有高的粘滞性。做错误的事情是容易的，但是做正确的事情却很难。</p>

<p>当开发环境迟钝、低效时，就会产生环境的粘滞性。</p>

<p>5.不必要的复杂性（Needless Complexity）</p>

<p>如果设计中包含有当前没有用的组成部分，它就含有不必要的复杂性。</p>

<p>6.不必要的重复（Needless Repetition）</p>

<p>当同样的代码以稍微不同的形式一再出现时，就表示开发人员忽视了抽象。</p>

<p>7.晦涩性（Opacity）</p>

<p>晦涩性是指模块难以理解。</p>

<p>在非敏捷环境中，由于需求没有按照初始设计预见的方式进行变化，从而导致了设计的退化。</p>

<p>设计必须要保持干净、简单，并且由于源代码是设计最重要的表示，所以它同样要保持干净。</p>

<p>敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能的简单、干净以及富有表现力。</p></blockquote>

<h2>第8章 单一职责原则（SRP）</h2>

<blockquote><p>就一个类而言，应该仅有一个引起它变化的原因。</p>

<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。</p>

<p>在SRP中，我们把职责定义为“变化的原因”（a reason for  change）。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>

<p>SRP是所有原则中最简单的之一，也是最难正确运用的之一。我们会自然地把职责结合在一起。软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</p></blockquote>

<h2>第9章 开放——封闭原则（OCP）</h2>

<blockquote><p>开放——封闭原则（The Open-Closed Principle，简称OCP）。</p>

<p>软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。</p>

<p>遵循开发——封闭原则设计出的模块具有两个主要的特征。它们是：</p>

<ol>
<li><p>“对于扩展是开放的”（Open for extension）。这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。换句话说，我们可以改变模块的功能。</p></li>
<li><p>“对于更改是封闭的”（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者Java的.jar文件，都无需改动。</p></li>
</ol>


<p>在C++、Java或者其他任何的OOPL中，可以创建出固定却能够描述一组任意个可能行为的抽象体。这个抽象体就是抽象基类。而这一组任意个可能的行为则表现为可能的派生类。</p>

<p>模块可以操作一个抽象体。由于模块依赖于一个固定的抽象体，所以它对于更改可以是关闭的。同时，通过从这个抽象体派生，也可以扩展此模块的行为。</p>

<p>STRATEGY模式</p>

<p>Template模式</p>

<p>一般而言，无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。没有对于所有的情况都贴切的模型。</p>

<p>既然不可能完全封闭，那么就必须有策略地对待这个问题。也就是说，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。</p>

<p>如果我们决定接受第一颗子弹，那么子弹到来的越早、越快就对我们越有利。</p>

<p>开发人员应该仅仅对程序中呈现出频繁变化的那些部分做出抽象。拒绝不成熟的抽象和抽象本身一样重要。</p></blockquote>

<h2>第10章 Liskov替换原则（LSP）</h2>

<blockquote><p>子类型（subtype）必须能够替换掉它们的基类型（base type）。</p>

<p>对于LSP的违反常常会导致以明显违反OCP的方式使用运行时类型辨别（RTTI）。这种方式常常是使用一个显式的if语句或者if/else链去确定一个对象的类型，以便于可以选择针对该类型的正确行为。</p>

<p>继承是IS-A（“是一个”）关系。也就是说，如果一个新类型的对象被认为和一个已有类的对象之间满足IS-A关系，那么这个新对象的类应该从这个已用对象的类派生。</p>

<p>LSP清楚地指出，OOD中IS-A关系是就行为方式而言的，行为方式是可以进行合理假设的，是客户程序所依赖的。</p>

<p>基于契约设计（Design By Contract，简称DBC）。使用DBC，类的编写者显式地规定针对该类的契约。客户代码的编写者可以通过该契约获悉可以依赖的行为方式。契约是通过为每个方法声明的前置条件（preconditions）和后置条件（postcondition）来指定的。要使一个方法得以执行，前置条件必须要为真。执行完毕后，该方法要保证后置条件为真。</p>

<p>在重新声明派生类中的例程（routine）时，只能使用相等或者更弱的前置条件来替换原始的前置条件，只能使用相等或者更强的后置条件来替换原始的后置条件。</p>

<p>也可以通过编写单元测试的方式来指定契约。单元测试通过彻底的测试一个类的行为来使该类的行为更加清晰。</p>

<p>不应该轻易放弃对于LSP的遵循。总是保证子类可以替代它的基类是一个有效的管理复杂性的方法。</p>

<p>可以把两个类的公共部分提取出来作为一个抽象基类。</p>

<p>有一些简单的启发规则可以提供一些有关违反LSP的提示。</p>

<ol>
<li><p>派生类中的退化函数</p></li>
<li><p>从派生类中抛出异常。如果基类的使用者不期望这些异常，那么把它们添加到派生类的方法中就会导致不可替换性。</p></li>
</ol>
</blockquote>

<h2>第11章 依赖倒置原则（DIP)</h2>

<blockquote><p>依赖倒置原则（DIP）</p>

<ol type="a">
<li><p>高层模块不应该依赖于低层模块。二者都应该依赖于抽象。</p></li>
<li><p>抽象不应该依赖于细节。细节应该依赖于抽象。</p></li>
</ol>


<p>一个设计良好的面向对象的程序，其依赖程序结构相对于传统的过程式方法设计的通常结构而言就是被“倒置”了。</p>

<p>无论如何高层模块都不应该依赖于低层模块。</p>

<p>如果高层模块独立于低层模块，那么高层模块就可以非常容易地被重用。该原则是框架（framework）设计的核心原则。</p>

<p>每个较高层次都为它所需要的服务声明一个抽象接口，较低的层次实现了这些抽象接口，每个高层类都通过该抽象接口使用下一层，这样高层就不依赖于低层。低层反而依赖于在高层中声明的抽象服务接口。</p>

<p>一个稍微简单但仍然非常有效的对于DIP的解释，是这样一个简单地启发式规则：“依赖于抽象。”</p>

<p>根据这个启发式规则，可知：</p>

<ul>
<li><p>任何变量都不应该持有一个指向具体类的指针或者引用</p></li>
<li><p>任何类都不应该从具体类派生</p></li>
<li><p>任何方法都不应该覆写它的任何基类中的已经实现了的方法</p></li>
</ul>


<p>我们在应用程序中所编写的大多数具体类都是不稳定的。我们不想直接依赖于这些不稳定的具体类。通过把它们隐藏在抽象接口的后面，可以隔离它们的不稳定性。</p>

<p>另一方面，如果看得更远一点，认为是由客户类来声明它们需要的服务接口，那么仅当客户需要时才会对接口进行改变。这样，改变实现抽象接口的类就不会影响到客户。</p>

<p>动态多态性</p>

<p>静态多态性</p>

<p>使用传统的过程化程序设计所创建出来的依赖关系结构，策略是依赖于细节的。这是糟糕的，因为这样会使策略受到细节改变的影响。面向对象的程序设计倒置了依赖关系结构，使得细节和策略都依赖于抽象，并且常常是客户拥有服务接口。</p></blockquote>

<h2>第12章 接口隔离原则（ISP）</h2>

<blockquote><p>如果类的接口不是内聚的（cohesive），就表示该类具有“胖”的接口。换句话说，类的“胖”接口可以分解成多组方法。每一组方法都服务于一组不同的客户程序。这样，一些客户程序可以使用一组成员函数，而其他客户程序可以使用其他组的成员函数。</p>

<p>不应该强迫客户依赖于它们不用的方法。</p>

<p>一个对象的客户不是必须通过该对象的接口去访问它，也可以通过委托或者通过该对象的基类去访问它。</p>

<p>胖类（fat class）会导致它们的客户程序之间产生不正常的并且有害的耦合关系。当一个客户程序要求该胖类进行一个改动时，会影响到所有其他的客户程序。因此，客户程序应该仅仅依赖于它们实际调用的方法。通过把胖类的接口分解为多个特定于客户程序的接口，可以实现这个目标。</p></blockquote>

<h1>第III部分 薪水支付案例研究</h1>

<h2>第13章 COMMAND模式和ACTIVE OBJECT模式</h2>

<p>命令模式。</p>

<blockquote><p>大多数类都是一组方法和相应的一组变量的组合。COMMAND模式不是这样的。它只是封装了一个没有任何变量的函数。</p>

<p>可以创建一个简单的文本文件来描述Sensor和Command之间的绑定关系。初始化程序可以读取该文件，并构建出对应的系统。这样，系统中的连接关系可以完全在程序以外确定，并且对它的调整也不会引起重新编译。</p>

<p>通过对命令（command）概念的封装，该模式解除了系统的逻辑互联关系和实际连接的设备之间的耦合。这是一个巨大的好处。</p>

<p>另外一个COMMAND模式的常见用法是创建和执行事务操作（Transactions）。</p>

<p>这给我们带来的好处在于很好地解除了从用户获取数据的代码、验证并操作数据的代码以及业务对象本身之间的耦合关系。</p>

<p>我们也以一种不同的方式解耦了验证和执行代码。一旦获取了数据，就没有理由要求验证和执行方法立即被调用。可以把事务操作对象放在一个列表中，以后再进行验证和执行。</p>

<p>给COMMAND模式增加了undo()方法。显而易见，如果Command派生类的do()方法可以记住它所执行的操作的细节，那么undo方法就可以取消这些操作，并把系统恢复到原先的状态。</p></blockquote>

<p>活动对象模式。</p>

<blockquote><p>ACTIVE OBJECT模式是实现多线程控制的一项古老的技术。……遍历链表，执行并去除每个命令。……如果链表中的一个Command对象会克隆自己并把克隆对象放到链表的尾部……这个链表永远不会为空，函数永远不会返回。……如果所等待的事件没有发生，它只是把自己放回。</p>

<p>采用该技术的变体（variations）去构建多线程系统已经是并且将会一直是一个很常见的实践。这种类型的线程被称为run-to-completion任务（RTC），因为每个Command实例在下一个Command可以运行之前就运行完成了。RTC的名字意味着Command实例不会阻塞。</p></blockquote>

<h2>第14章 TEMPLATE METHOD模式和STRATEGY模式：继承与委托</h2>

<p>模版方法模式。</p>

<blockquote><p>继承非常容易被过度使用，而且过度使用的代价是非常高的。所以我们减少了对继承的使用，常常使用组合或者委托来代替它。</p>

<p>TEMPLATE METHOD模式使用继承来解决问题，而STRATEGY模式使用的则是委托。</p>

<p>编写过的所有程序，其中许多可能都具有如下的基本主循环结构：首先进行初始化；接着进入主循环；在主循环中完成需要做的工作；最后，一旦完成了工作，程序就退出主循环，并且在程序终止前做些清除工作。</p>

<p>TEMPLATE METHOD模式把所有通用代码放入一个抽象基类（abstract base class）的实现方法中。这个实现方法完成了这个通用算法，但是将所有的实现细节都交付给该基类的抽象方法。</p></blockquote>

<p>通过继承基类，只需要实现基类中的抽象方法即可。</p>

<blockquote><p>设计模式是很好的东西。它们可以帮助解决很多设计问题。但是它们的存在并不意味着必须要经常使用它们。</p>

<p>TEMPLATE METHOD模式展示了面向对象编程中诸多经典重用形式中的一种。其中通用算法被放置在基类中，并且通过继承在不同的具体上下文中实现该通用算法。但是这项技术是有代价的。继承是一种非常强的关系。派生类不可避免地要和它们的基类绑定在一起。</p></blockquote>

<p>策略模式。</p>

<blockquote><p>STRATEGY模式使用了一种非常不同的方法来倒置通用算法和具体实现之间的依赖关系。</p>

<p>不是将通用的应用算法放进一个抽象基类中，而是将它放进一个具体类中。把通用算法必须要调用的抽象方法定义在一个借口中。从这个接口中派生出类，并把它传给放有通用算法的具体类。之后，该类就可以把具体工作委托给这个接口去完成。</p>

<p>STRATEGY模式比TEMPLATE METHOD模式多提供了一个额外的好处。尽管TEMPLATE METHOD模式允许一个通用算法操纵多个可能的具体实现，但是由于STRATEGY模式完全遵循DIP原则，从而允许每个具体实现都可以被多个不同的通用算法操纵。不过要以一些额外的复杂性、内存以及运行时间开销作为代价。</p></blockquote>

<h2>第15章 FACADE模式和MEDIATOR模式</h2>

<p>外观模式。</p>

<blockquote><p>这两个模式都把某种策略（policy）施加到另外一组对象上。FACADE模式从上面施加策略，而MEDIATOR模式则是从下面施加策略。FACADE模式的使用是明显且受限的，而MEDIATOR模式的使用则是不明显且不受限制的。</p>

<p>当想要为一组具有复杂且全面的接口的对象提供一个简单且特定的接口时，可以使用FACADE模式。它对用户隐藏了所有的复杂性。</p></blockquote>

<p>中介者模式。</p>

<blockquote><p>MEDIATOR模式把它的策略施加在那些对象上，而无需它们的允许或者知晓。</p>

<p>如果策略涉及范围广泛并且可见，那么可以使用FACADE模式从上面施加该策略。另一方面，如果策略隐蔽并且有针对性，那么MEDIATOR模式是更好的选择。Facades通常是约定的关注点。每个人都同意去使用该facade而不是隐藏于其下的对象。另一方面，Mediator则对用户是隐藏的。它的策略是既成事实的而不是一项约定事务。</p></blockquote>

<h2>第16章 SINGLETON模式和MONOSTATE模式</h2>

<p>单例模式。</p>

<blockquote><p>然而有一些类，它们应该只有一个实例。</p></blockquote>

<p>实现SINGLETON模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>

<blockquote><p>SINGLETON模式的好处：跨平台；适用于任何类；可以透过派生创建；延迟求值（Lazy evaluation）。</p>

<p>MONOSTATE模式是另外一种获取对象单一性的方法。</p></blockquote>

<p>使多个实例表现得像一个对象，只需要它们共享相同的变量。只要把所有的变量都变成静态变量即可。</p>

<blockquote><p>这两个模式之间的区别，在于一个关注行为，而另一个关注结构。SINGLETON模式强制结构上的单一性。它防止创建出多个对象实例。相反，MONOSTATE模式则强制行为上的单一性，而没有强加结构方面的限制。</p>

<p>MONOSTATE模式的好处：透明性；可派生性；多态性。</p></blockquote>

<h2>第17章 NULL OBJECT模式</h2>

<p>空对象模式。</p>

<blockquote><p>通常，该模式会消除对null进行检查的需要，并且有助于简化代码。</p>

<p>使用该模式，我们可以确保函数总是返回有效的对象，即使在它们失败时也是如此。这些代表失败的对象“什么也不做”。</p></blockquote>

<p>（先挖坑，马上填）</p>

<p><img class="left" src="/images/2015/agile-software-development.jpg" width="98" height="137"></p>

<p><a href="http://book.douban.com/subject/1140457/">敏捷软件开发：原则、模式与实践</a> - <a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">Robert C. Martin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员的职业素养》读书笔记]]></title>
    <link href="http://boxingp.github.io/blog/2015/02/02/the-clean-coder-reading-notes/"/>
    <updated>2015-02-02T22:01:58+08:00</updated>
    <id>http://boxingp.github.io/blog/2015/02/02/the-clean-coder-reading-notes</id>
    <content type="html"><![CDATA[<p>一本“方法论”的书，把程序员作为自己的工作确实需要一些态度，以及一些指导。看了之后了解到不少，做了摘录。希望可以对自己起到一些帮助。目标是，成为“专业人士”以及更好的自己。</p>

<!-- more -->


<h2>引言</h2>

<blockquote><p>请你把这本书看成我的错误大全，它记录了我干过的所有蠢事；也请你把这本书当成一份指引，让它带你绕开我曾经走过的弯路。</p></blockquote>

<h2>第一章 专业主义</h2>

<h3>1.1 清楚你要什么</h3>

<blockquote><p>“专业主义”有很深的含义，它不但象征着荣誉与骄傲，而且明确意味着责任与义务。</p>

<p>实际上，专业主义的精髓就在于将公司利益视同个人利益。</p></blockquote>

<h3>1.2 担当责任</h3>

<h3>1.3 首先，不行损害之事</h3>

<blockquote><p>“希波克拉底誓言”</p></blockquote>

<p>“敬禀醫神阿波羅、阿斯克勒庇俄斯、許癸厄亞、帕那刻亞，及天地諸神聖鑒之，鄙人敬謹宣誓：</p>

<p> 余願盡己之能力與判斷力之所及，矢守此約。凡授余藝者：余敬如父母，為終身同甘共苦之侶；倘有急需余必接濟。視彼兒女，猶余手足，如欲受業，余無償、無條件傳授之。凡余之所知，無論口授、書傳俱傳之吾子、吾師之子、及立誓守此約之生徒，此外不傳他人。</p>

<p> 余願盡己之能力與判斷力之所及，恪守為病家謀福之信條，並避免一切墮落害人之敗行，余必不以毒物藥品與他人，並不作此項之指導，雖人請求亦必不與之，尤不為婦人施墮胎之術。余願以此純潔神聖之心，終身執行余之職務。至於手術，另待高明，余不施之，遇結石患者亦然，惟使專匠為之。</p>

<p> 無論何適何遇，逢男或女，民人奴隸，余之唯一目的，為病家謀福，並檢點吾身，不為種種墮落害人之敗行，尤不為誘姦之事。凡余所見所聞，不論有無業務之牽連，余以為不應洩漏者，願守口如瓶。</p>

<p> 倘余嚴守上述之誓詞，願神僅僅使余之生命及醫術，得無上之光榮；余苟違誓，天地鬼神共殛之！”  <a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E6%B3%A2%E5%85%8B%E6%8B%89%E5%BA%95%E8%AA%93%E8%A9%9E">Wikipedia</a></p>

<h4>1.3.1 不要破坏软件的功能</h4>

<blockquote><p>所谓专业人士，就是能对自己犯下的错误负责的人，哪怕那些错误实际上在所难免。所以，雄心勃勃的专业人士们，你们要练习的第一件事就是“道歉”。道歉是必要的，但还不够。你不能一而再、再而三地犯相同的错误。</p>

<p>失误率永远不可能等于零，但你有责任让它无限接近零。</p></blockquote>

<h5>1.让QA找不出任何问题</h5>

<blockquote><p>什么样的代码是有缺陷的呢？那些你没把握的代码都是！</p></blockquote>

<h5>2.要确信代码正常运行</h5>

<blockquote><p>你怎么知道代码能否常运行呢？很简单，测试！</p>

<p>实行自动化测试。</p>

<p>你写的每一行代码都要测试。</p>

<p>但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码。</p></blockquote>

<h5>3.自动化QA</h5>

<blockquote><p>你的自动化测试至少要能够让你知道，你的系统很有可能通过QA的测试。</p></blockquote>

<h4>1.3.2 不要破坏结构</h4>

<blockquote><p>结构良好的代码更灵活。</p>

<p>所有软件项目的根本指导原则是，软件要易于修改。</p>

<p>如果你希望自己的软件灵活可变，那就应该时常修改它！</p>

<p>“无情重构”，我把它叫作“童子军训练守则”：对每个模块，每检入一次代码，就要让它比上次检出时变得更为简洁。每次读代码，都别忘了进行点滴的改善。</p></blockquote>

<p>测试就是帮助你检查每次改动是否会与开始时的需求相违背。</p>

<h3>1.4 职业道德</h3>

<blockquote><p>职业发展是你自己的事。雇主没有义务确保你在职场能够立于不败之地，也没义务培训你，送你参加各种会议或给你买各种书籍充电。这些都是你自己的事。将自己的职业发展寄希望于雇主的软件开发人员将会很惨。</p>

<p>雇主出了钱，你必须付出时间和精力。</p></blockquote>

<p>不能赞同更多。</p>

<h4>1.4.1 了解你的领域</h4>

<blockquote><p>近50年来，各种观点、实践、技术、工具与术语在我们这一领域层出不穷。你对这些了解多少呢？如果想成为一名专业开发者，那你就得对其中的相当一大部分有所了解，而且要不断扩展这一知识面。</p>

<ul>
<li><p>设计模式。必须能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验。</p></li>
<li><p>设计原则。必须了解SOLID原则，而且要深刻理解组件设计原则。</p></li>
<li><p>方法。必须理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等。</p></li>
<li><p>实践。必须掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程。</p></li>
<li><p>工件。必须了解如何使用UML图、DFD图、结构图、Petri网络图、状态迁移图表、流程图和决策图。</p></li>
</ul>
</blockquote>

<h4>1.4.2 坚持学习</h4>

<blockquote><p>读书，看相关文章，关注博客和微博，参加技术大会，访问用户群，多参与读书与学习小组。不懂就学，不要畏难。</p></blockquote>

<h4>1.4.3 练习</h4>

<blockquote><p>业精于勤。</p>

<p>练习，指的是在日常工作之余专门练习技能，以期自我提升。</p></blockquote>

<h4>1.4.4 合作</h4>

<blockquote><p>学习的第二个最佳方法是与他人合作。</p></blockquote>

<h4>1.4.5 辅导</h4>

<blockquote><p>想迅速牢固地掌握某些事实和观念，最好的方法就是与由你负责的人交流这些内容。</p></blockquote>

<p>分享知识时也是这样，自己事先需要好好备课。</p>

<h4>1.4.6 了解业务领域</h4>

<blockquote><p>每位专业软件开发人员都有义务了解自己开发的解决方案所对应的业务领域。</p></blockquote>

<h4>1.4.7 与雇主/客户保持一致</h4>

<blockquote><p>每次开发系统，都应该站在雇主的角度来思考，确保开发的功能真正能满足雇主的需要。</p></blockquote>

<h4>1.4.8 谦逊</h4>

<blockquote><p>他从不会嘲讽别人，自作自受时他会接受别人的嘲讽。反之，他则会一笑了之。</p></blockquote>

<h2>第二章 说“不”</h2>

<blockquote><p>专业人士敢于说明真相而不屈从于权势。</p></blockquote>

<h3>2.1 对抗角色</h3>

<blockquote><p>我的个人经验告诉自己，要做出艰难决定的时候，存在对抗角色间的冲突于此是最为有利的。</p></blockquote>

<h3>2.2 高风险时刻</h3>

<blockquote><p>最要说“不”的是那些高风险的关键时刻。越是关键时刻，“不”字就越具价值。</p></blockquote>

<h3>2.3 要有团队精神</h3>

<h4>2.3.1 试试看</h4>

<blockquote><p>没有“试试看”这回事。</p>

<p>许诺“尝试”，就意味着你承认自己之前未尽全力，承认自己还有余力可施。</p>

<p>如果你此前并未有所保留，如果你没有新方案，如果你不会改变你的行为，如果你对自己原先的估计有充分的自信，那么，从本质上讲，承诺“尝试”就是一种不诚实的表现。</p></blockquote>

<p>很多时候也许是避免冲突，大家习惯上说“试试看”，如果对自己自信，而且有着负责任的态度，更应该对一些很难做到的需求说“不”。</p>

<h4>2.3.2 消极对抗</h4>

<blockquote><p>如果一列载货列车向大家冲过来，而只有你一人有所察觉，你可以轻轻抽身退到轨道外，眼看其他人被车碾过，也可以大喊：“车！车来了！快离开！”</p></blockquote>

<h3>2.4 说“是”的成本</h3>

<blockquote><p>有时候，获取正确决策的唯一途径，便是勇敢无畏地说出“不”字。</p></blockquote>

<h3>2.5 如何写出好代码</h3>

<blockquote><p>成为英雄及“解决问题”的诱惑诚然巨大，只是我们要明白，委屈专业原则以求全，并非问题的解决之道。舍弃这些原则，只会制造出更多的麻烦。</p></blockquote>

<h2>第三章 说“是”</h2>

<h3>3.1 承诺用语</h3>

<blockquote><p>口头上说。心里认真。付诸行动。</p>

<p>做出承诺，包含三个步骤。</p>

<p>(1) 口头上说自己将会去做。</p>

<p>(2) 心里认真对待做出的承诺。</p>

<p>(3) 真正付诸行动。</p></blockquote>

<h4>3.1.1 识别“缺乏承诺”的征兆</h4>

<blockquote><p>在承诺做某事时，应当留意自己的用词，因为这些用词透露了我们对待承诺的认真程度。</p></blockquote>

<h4>3.1.2 真正的承诺听起来是怎样的</h4>

<blockquote><p>你对自己将会做某件事做了清晰的事实陈述，而且还明确说明了完成期限。</p></blockquote>

<h3>3.2 学习如何说“是”</h3>

<h4>3.2.1 “试试”的另一面</h4>

<blockquote><p>“试试”，则是“可能做得到，也可能做不到”的意思。</p></blockquote>

<h4>3.2.2 坚守原则</h4>

<blockquote><p>如果是专业开发人员，就不会放弃底线。</p>

<p>多年经验告诉我们，打破这些纪律和原则，必然会拖慢进度。</p>

<p>身为专业开发人员，有责任根据标准规范自身工作。</p>

<p>专业人士对自己的能力极限了如指掌。他们十分清楚自己还能保持效率加班多长时间，也非常明白要付出的代价。</p></blockquote>

<h2>第四章 编码</h2>

<blockquote><p>具备“出错感知能力”，说明你已经能够非常迅速地获得反馈，能够更为快速地从错误中学习。</p>

<p>要精熟掌握每项技艺，关键都是要具备“信心”和“出错感知”能力。</p></blockquote>

<h3>4.1 做好准备</h3>

<blockquote><p>相比其他类型的活动，编码要求更加聚精会神。因为在编码时你必须平衡互相牵制的多种因素。</p>

<p>(1) 首先，代码必须能够正常工作。必须理解当前要解决的是什么问题以及该如何解决。必须确保编写的代码忠实遵循解决方案。必须管理好解决方案的每一处细节，并且使语言、平台、现有架构以及当前系统的所有问题和平共处。</p>

<p>(2) 代码必须能够帮你解决客户提出的问题。</p>

<p>(3) 代码必须要能和现有系统结合的天衣无缝。</p>

<p>(4) 其他程序员必须能读懂你的代码。</p>

<p>如果感到疲劳或者心烦意乱，千万不要编码。</p></blockquote>

<h4>4.1.1 凌晨3点写出的代码</h4>

<blockquote><p>疲劳的时候，千万不要写代码。奉献精神和职业素养，更多意义上指要遵循纪律原则而非成为长时间工作的工作狂。要确保自己已经将睡眠、健康和生活方式调整到最佳状况，这样才能做到在每天的8小时工作时间内全力以赴。</p></blockquote>

<h4>4.1.2 焦虑时写下的代码</h4>

<blockquote><p>理想情况下，应该使用个人时间去解决个人问题。</p>

<p>专业开发人员善于合理分配个人时间，以确保工作时间段中尽可能富有成效。</p></blockquote>

<h3>4.2 流态区</h3>

<blockquote><p>这是程序员在编写代码时会进入的一种意识高度专注但思维视野却会收拢到狭窄的状态。</p>

<p>避免进入流态区。这种意识状态并非真的极为高效，也绝非毫无错误。这其实只是一种“浅层冥想”状态，在这种状态下，为了追求所谓的速度，理性思考的能力会下降。</p>

<p>结对编程最大的一个好处在于，结对中的任一方都不可能进入流态区。流态区是一种隔绝沟通的状态，而结对则要求激励持续地进行沟通。</p></blockquote>

<h4>4.2.1 音乐</h4>

<blockquote><p>在听音乐时无法写好代码。</p></blockquote>

<h4>4.2.2 中断</h4>

<blockquote><p>结对是用以应对中断的一种好方法。</p>

<p>另一种很有帮助的方法便是采用TDD。</p></blockquote>

<h3>4.3 阻塞</h3>

<blockquote><p>有一个很简单的好办法可以解决这个问题。这个方法便是：找一个搭档结对编程。</p>

<p>结对带来的主要好处是它能够帮我重新激活思维。</p>

<p>还有其他一些事物可以让我免于陷入阻塞状态。“创造性输出”依赖于“创造性输入”。</p></blockquote>

<h3>4.4 调试</h3>

<blockquote><p>不管是否采纳TDD或其他一些同等效果的实践，衡量你是否是一名专业人士的一个重要方面，便是看你是否能将调试时间尽量降到最低。绝对的零调试时间是一个理想化的目标，无法达到，但要将之作为努力方向。</p></blockquote>

<h3>4.5 保持节奏</h3>

<blockquote><p>软件开发是一场马拉松，而不是短跑冲刺。</p></blockquote>

<h4>4.5.1 知道何时应该离开一会</h4>

<h4>4.5.2 开车回家路上</h4>

<h4>4.5.1 洗澡</h4>

<h3>4.6 进度延迟</h3>

<blockquote><p>管理延迟的诀窍，便是早期检测和保持透明。</p>

<p>根据目标定期衡量进度，使用三个考虑到多种因素的期限：乐观预估、标称预估、悲观预估。尽量严守这三个时间点。</p></blockquote>

<h4>4.6.1 期望</h4>

<blockquote><p>期望会破坏项目进度表。</p></blockquote>

<h4>4.6.2 盲目冲刺</h4>

<blockquote><p>不要经受不住诱惑盲目冲刺。</p></blockquote>

<h4>4.6.3 加班加点</h4>

<blockquote><p>不应该采用额外加班加点工作的方案，除非以下三个条件都能满足：(1)你个人能挤出这些时间；(2)短期加班，最多加班两周；(3)你的老板要有后备预案，以防万一加班措施失败。</p></blockquote>

<h4>4.6.4 交付失误</h4>

<blockquote><p>在程序员所能表现的各种不专业行为中，最糟糕的是明知道还没有完成任务却宣称已经完成。</p></blockquote>

<h4>4.6.5 定义完成</h4>

<blockquote><p>可以通过创建一个确切定义的“完成”标准来避免交付失误。最好的方法是让业务分析师和测试人员创建一个自动化的验收测试，只有完全通过这些验收测试，开发任务才能算已经完成。</p></blockquote>

<h3>4.7 帮助</h3>

<blockquote><p>即使你的技能格外高超，也肯定能从另外一名程序员的思考与想法中获益。</p></blockquote>

<h4>4.7.1 帮助他人</h4>

<h4>4.7.2 接受他人的帮助</h4>

<h4>4.7.3 辅导</h4>

<blockquote><p>辅导缺乏经验的程序员是那些经验丰富的程序员的职责。</p>

<p>同样道理，向资深导师寻求辅导也是年轻程序员的专业职责。</p></blockquote>

<h2>第五章 测试驱动开发</h2>

<h3>5.1 此时已有定论</h3>

<h3>5.2 TDD的三项法则</h3>

<blockquote><p>(1)在编好失败单元测试之前，不要编写任何产品代码。</p>

<p>(2)只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况。</p>

<p>(3)产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。</p></blockquote>

<h3>5.3 TDD的优势</h3>

<h4>5.3.1 确定性</h4>

<h4>5.3.2 缺陷注入率</h4>

<blockquote><p>有不少报告和研究称TDD能够显著降低缺陷。</p></blockquote>

<h4>5.3.3 勇气</h4>

<blockquote><p>拥有一套值得信赖的测试，便可完全打消对修改代码的全部恐惧。</p></blockquote>

<h4>5.3.4 文档</h4>

<blockquote><p>单元测试即是文档。</p></blockquote>

<h4>5.3.5 设计</h4>

<blockquote><p>测试代码的一个问题是必须隔离出待测试的代码。</p>

<p>因此，遵循三项法则并且测试先行，便能够产生一种驱动力，促使你做出松耦合的设计。</p></blockquote>

<h4>5.3.6 专业人士的选择</h4>

<blockquote><p>TDD是专业人士的选择。</p></blockquote>

<h3>5.4 TDD的局限</h3>

<p>TDD大法好。在学写代码的开始，就是想着怎么实现怎么写，写出来的代码很糟糕。后来在别人的帮助下系统的学习敏捷的一套流程，发现TDD确实很实用。持续集成的局限可能是你要多一台机子去跑CI，TDD的局限我目前还没有注意到，这也是自己功力尚浅的原因。会在后面一直实践下去。</p>

<h2>第六章 练习</h2>

<h3>6.1 引子</h3>

<h4>6.1.1 10的22次方</h4>

<h4>6.1.2 转变</h4>

<blockquote><p>无论是搏斗还是编程，速度都来源于练习。</p></blockquote>

<h3>6.2 编程柔道场</h3>

<p>The Coding Dojo</p>

<blockquote><p>就像习武的人那样，有时候一群程序员聚在一起练习，也有些时候是独自练习。</p></blockquote>

<h4>6.2.1 卡塔</h4>

<p>Kata</p>

<blockquote><p>编程卡塔也是一整套敲击键盘和鼠标的动作，用来模拟编程问题的解决过程。</p>

<p>编程卡塔的最终目标，也是逐步练习以达到纯熟。反复的练习会训练大脑和手指如何动作和反应。</p>

<p>要学习热键和导航操作，以及测试驱动开发、持续集成之类的方法，找整套的卡塔来练习都是相当有效的。更重要的是，它特别有利于在潜意识中构筑通用的问题与解决方案间的联系。</p></blockquote>

<h4>6.2.2 瓦萨</h4>

<p>Wasa</p>

<blockquote><p>瓦萨基本可以说是两个人的卡塔。</p>

<p>两个人选择一个卡塔，或者一个简单问题，一个人写单元测试，另一个人写程序通过单元测试，然后交换角色。</p></blockquote>

<h4>6.2.3 自由练习</h4>

<p>Randori</p>

<blockquote><p>在自由练习中，屏幕被投影到墙上，一个人写测试，然后坐下来，另一个人写程序通过测试，再写下一个测试。桌子边的人一个个轮流接下去，或者有兴趣的人可以自己排队参加。</p></blockquote>

<h3>6.3 自身经验的扩展</h3>

<h4>6.3.1 开源</h4>

<blockquote><p>保持不落伍的一种方法是为开源项目贡献代码。</p></blockquote>

<h4>6.3.2 关于练习的职业道德</h4>

<blockquote><p>职业程序员用自己的时间来练习。</p></blockquote>

<p>之前在TWU把三种Dojo的方式都练习过，但是当时读书少，不知道它们的名字，只是觉得很有意思，也了解到不同人的思考问题的方式。现在看来茅塞顿开。喜欢书里面提到的一句话，“老板的职责不包括避免你的技术落伍，也不包括为你打造一份好看的履历”。嗯，更多的练习，让自己进步。</p>

<h2>第七章 验收测试</h2>

<h3>7.1 需求的沟通</h3>

<blockquote><p>开发方与业务方之间最常见的沟通是关于需求的。</p></blockquote>

<h4>7.1.1 过早精细化</h4>

<blockquote><p>做业务的人和写程序的人都容易陷入一个陷阱，即过早进行精细化。</p></blockquote>

<h4>7.1.2 迟来的模糊性</h4>

<blockquote><p>避免过早精细化的方法是尽可能地推迟精细化。</p>

<p>但是，这可能造成另一个问题：迟来的模糊性。</p>

<p>“需求文档中的每一点模糊之处，都对应着业务方的一点分歧。”</p></blockquote>

<h3>7.2 验收测试</h3>

<blockquote><p>业务方与开发方合作编写的测试，其目的在于确定需求已经完成。</p></blockquote>

<h4>7.2.1 “完成”的定义</h4>

<blockquote><p>完成意味着所有的代码都写完了，所有的测试都通过了，QA和需求方已经认可。</p>

<p>专业开发人员会根据自动化的验收测试来定义需求。</p></blockquote>

<h4>7.2.2 沟通</h4>

<blockquote><p>验收测试的目的是沟通、澄清、精确化。</p></blockquote>

<h4>7.2.3 自动化</h4>

<blockquote><p>验收测试都应当自动进行。</p></blockquote>

<p>接触过Cucumber的测试，但是没有实现过，应该尝试一下，写写自动化的验收测试。</p>

<h4>7.2.4 额外工作</h4>

<blockquote><p>不要把它们（测试）看作额外的工作，而应当看成节省时间和金钱的办法。这些测试可以避免你的开发误入歧途，也可以帮你确认自己已经完工。</p></blockquote>

<h4>7.2.5 验收测试什么时候写，由谁来写</h4>

<blockquote><p>通常，业务分析员测试“正确路径”，以证明功能的业务价值；QA则测试“错误路径”、边界条件、异常、例外情况。</p>

<p>在敏捷项目中，只有在选定了下一轮迭代（Iteration）或当前冲刺（Sprint）所需要的功能之后，才编写测试。</p>

<p>迭代开始的第一天，就应当准备好最初的几项验收测试。然后每天都应当完成一些验收测试，到迭代的中间点，所有的测试都应当准备完毕。</p></blockquote>

<h4>7.2.6 开发人员的角色</h4>

<blockquote><p>实现某项功能的代码，应该在对应的验收测试完成后开始。开发人员运行这些验收测试，观察失败的原因，将验收测试与系统联系起来，然后实现需要的功能，让测试通过。</p></blockquote>

<h4>7.2.7 测试的协商与被动推进</h4>

<blockquote><p>身为专业开发人员，与编写测试的人协商并改进测试是你的职责。</p></blockquote>

<h4>7.2.8 验收测试和单元测试</h4>

<blockquote><p>验收测试不是单元测试。单元测试是程序员写给程序员的，它是正式的设计文档，描述了底层结构及代码的行为。</p>

<p>验收测试是业务方写给业务方的。它们是正式的需求文档，描述了业务方认为系统应该如何运行。</p>

<p>它们的主要功能其实不是测试，测试只是它们的附属职能。单元测试和验收测试首先是文档，然后才是测试。</p></blockquote>

<h4>7.2.9 图形界面及其他复杂因素</h4>

<blockquote><p>通过GUI背后的API来测试业务逻辑。</p>

<p>有些验收测试规定了GUI自身的行为。这些测试必须通过GUI。但是，这些测试并不是测试业务逻辑的，所以不需要业务规则关联到GUI。最好把GUI和业务规则解耦合，在测试GUI时，用测试桩替代业务规则。</p>

<p>应当尽可能地减少GUI测试。</p></blockquote>

<h4>7.2.10 持续集成</h4>

<blockquote><p>保持持续集成系统的时刻运行是非常重要的。</p>

<p>在持续集成系统里，失败的集成应该视为紧急情况，也就是“立刻中止”型事件。</p></blockquote>

<p>我们最怕的就是在周五下午提交代码，挂的死去活来的CI是每个人的噩梦。</p>

<h3>7.3 结论</h3>

<blockquote><p>要解决开发方和业务方沟通问题，我所知道的唯一有效的办法就是编写自动化的验收测试。</p></blockquote>

<h2>第八章 测试策略</h2>

<blockquote><p>每个专业的开发团队都需要一套好的测试策略。</p></blockquote>

<h3>8.1 QA应该找不到任何错误</h3>

<blockquote><p>对QA找到的每一个问题，开发团队都应该高度重视、认真对待。应该反思为什么会出现这种错误，并采取措施避免今后重犯。</p></blockquote>

<h4>8.1.1 QA也是团队的一部分</h4>

<blockquote><p>QA在团队中要扮演的便是需求规约定义着（specifier）和特性描述者（characterizer）。</p></blockquote>

<h4>8.1.2 需求规约定义者</h4>

<blockquote><p>QA的任务便是和业务人员一起创建自动化验收测试，作为系统真正的需求规约文档。每轮迭代中，他们都可以从业务人员那里收集需求，将之翻译为向开发人员描述系统行为的测试。通常，业务人员编写针对正常路径的测试（happy-pathtest），而由QA编写针对极端情况（corner）、边界状态（boundary）和异常路径（unhappy-pathtest）的测试。</p></blockquote>

<h4>8.1.3 特性描述者</h4>

<blockquote><p>QA的另一项任务是遵循探索式测试的原则，描述系统运行中的真实情况，将之反馈给开发人员和业务人员。</p></blockquote>

<h3>8.2 自动化测试金字塔</h3>

<h4>8.2.1 单元测试</h4>

<p>Unit tests</p>

<blockquote><p>在金字塔底部是单元测试，这些测试由程序员使用与系统开发相同的语言来编写，供程序员自己使用。</p></blockquote>

<h4>8.2.2 组件测试</h4>

<p>Component tests</p>

<blockquote><p>组件测试是验收测试的一种。通常，它们是针对系统的各个组件而编写的。系统的组件封装了业务规则，因此，对这些组件的测试便是对其中业务规则的验收测试。</p>

<p>在组件测试中，需要使用合适的模拟（mocking）或测试辅助（test-doubling）技术，解开与系统的其他组件的耦合。</p>

<p>组件测试由QA和业务人员编写，开发人员提供辅助。它们需要在FitNesse、JBehave或Cucumber等组件测试环境下编写。其目的是让不具备编写测试能力的业务人员也能理解这些测试。</p>

<p>它们更主要测试的是成功路径的情况，以及一些明显的极端情况、边界状态和可选路径。大多数的异常路径是由单元测试来覆盖测试的。</p></blockquote>

<h4>8.2.3 集成测试</h4>

<p>Integration tests</p>

<blockquote><p>这些测试将组件装配成组，测试它们彼此之间是否能正常通信。</p>

<p>集成测试是编排性（choreography）测试。它们并不会测试业务规则，而是主要测试组件装配在一起是否协调。</p>

<p>在这个层次上，也许已经可以进行性能测试和吞吐率测试了。</p></blockquote>

<h4>8.2.4 系统测试</h4>

<p>System tests</p>

<blockquote><p>这些测试是针对整个集成完毕的系统来运行的自动化测试，是最终的集成测试。它们不会直接测试业务规则，而是测试系统是否已正确组装完毕，以及系统各个组成部件之间是否能正确交互。在这个层次的测试集中，应该包含吞吐率测试和性能测试。</p></blockquote>

<h4>8.2.5 人工探索性测试</h4>

<blockquote><p>这是需要人工介入、敲击键盘、盯牢屏幕的测试。</p>

<p>探索式测试不是要证明每条业务规则、每条运行路径都正确，而是要确保系统在人工操作下表现良好，同时富有创造性地找出尽可能多的“古怪之处”。</p></blockquote>

<h3>8.3 结论</h3>

<p>这下更清楚不同测试的目的了。觉得有时间要把<a href="http://en.wikipedia.org/wiki/Kent_Beck">Kent Beck</a>的<a href="http://book.douban.com/subject/1771049/">Test Driven Development: By Example</a>好好地读一下。作者由Kent手把手教TDD，羡慕。</p>

<p>这里有必要说一句，之前用TDD更多的是写Unit tests，所以对TDD的使用可能有些混淆了概念。TDD测试的是Features, 不是“Units”，有时候Features和Units有关，但更多的时候是无关的。</p>

<h2>第九章 时间管理</h2>

<h3>9.1 会议</h3>

<blockquote><p>关于会议，有两条真理：</p>

<ul>
<li><p>(1)会议是必需的；</p></li>
<li><p>(2)会议浪费了大量的时间。</p></li>
</ul>
</blockquote>

<h4>9.1.1 拒绝</h4>

<blockquote><p>受到邀请的会议没有必要全部参加。</p></blockquote>

<h4>9.1.2 离席</h4>

<blockquote><p>如果会议让人厌烦，就离席。</p></blockquote>

<h4>9.1.3 确定议程与目标</h4>

<blockquote><p>为了合理使用与会者的时间，会议应当有清晰的议程，确定每个议题所花的时间，以及明确的目标。</p></blockquote>

<h4>9.1.4 立会</h4>

<blockquote><p>到场的人依次回答以下3个问题：</p>

<ul>
<li><p>(1)我昨天干了什么？</p></li>
<li><p>(2)我今天打算干什么？</p></li>
<li><p>(3)我遇到了什么问题？</p></li>
</ul>
</blockquote>

<p>站会对团队了解彼此的工作进度很有帮助，还能帮助自己整理思路。要是前一天的产出很低，会不好意思的。</p>

<h4>9.1.5 迭代计划会议</h4>

<blockquote><p>迭代计划会议用来选择在下一轮迭代中实现的开发任务。在会议召开前必须完成两项任务：评估可选择任务的开发时间，确定这些任务的业务价值。</p></blockquote>

<h4>9.1.6 迭代回顾和DEMO展示</h4>

<h4>9.1.7 争论/反对</h4>

<blockquote><p>“凡是不能在5分钟内解决的争论，都不能靠辩说解决。”</p>

<p>唯一的出路是，用数据说话。</p></blockquote>

<h3>9.2 注意力点数</h3>

<blockquote><p>职业开发人员会学习安排时间，妥善使用自己的注意力点数。</p></blockquote>

<h4>9.2.1 睡眠</h4>

<h4>9.2.2 咖啡因</h4>

<h4>9.2.3 恢复</h4>

<h4>9.2.4 肌肉注意力</h4>

<blockquote><p>肌肉注意力有助于改善心智注意力，而且不仅仅是简单的恢复。</p></blockquote>

<h4>9.2.5 输入与输出</h4>

<blockquote><p>关于注意力，我知道的另一重点是平衡输入与输出。</p></blockquote>

<h3>9.3 时间拆分和番茄工作法</h3>

<blockquote><p>番茄工作法的真正好处在于，在25分钟的高效工作时间段里，你有底气拒绝任何干扰。</p></blockquote>

<p>看来要好好实践一下番茄工作法。之前一直使用的是<a href="https://itunes.apple.com/cn/app/ci-ke-fan-jia-zhong-ding-shi/id885381944?l=en&amp;mt=8">此刻</a>，看来要继续下去。</p>

<h3>9.4 要避免的行为</h3>

<blockquote><p>优先级错乱——提高某个任务的优先级，之后就有借口推迟真正急迫的任务。</p>

<p>专业开发人员会评估每个任务的优先级，排除个人的喜好和需要，按照真实的紧急程度来执行任务。</p></blockquote>

<h3>9.5 死胡同</h3>

<blockquote><p>在走入死胡同时可以迅速意识到，并有足够的勇气走回头路。这就是所谓的坑法则（The Rule of Holes）：如果你掉进了坑里，别挖。</p></blockquote>

<h3>9.6 泥潭</h3>

<blockquote><p>比死胡同更糟的是泥潭。</p>

<p>走回头路看起来代价很高，因为要把已有代码推翻重来，但是走回头路绝对是最简单的方法。</p></blockquote>

<h3>9.7 结论</h3>

<blockquote><p>专业开发人员会用心管理自己的时间和注意力。他们知道优先级错乱的诱惑，他们也珍视自己的声誉，所以会抵制优先级错乱。他们永远有多种选择，永远敞开心扉听取其他解决方案，他们从来不会执拗于某个无法放弃的解决方案。他们也时刻警惕着正在显露的泥潭，一旦看清楚，就会避开。</p></blockquote>

<h2>第十章 预估</h2>

<h3>10.1 什么是预估</h3>

<blockquote><p>业务方觉得预估就是承诺。开发方认为预估就是猜测。</p></blockquote>

<h4>10.1.1 承诺</h4>

<blockquote><p>承诺是必须做到的。</p>

<p>承诺是关于确定性的。</p></blockquote>

<h4>10.1.2 预估</h4>

<blockquote><p>预估是一种猜测。</p>

<p>预估不是个定数，预估的结果是一种概率分布。</p></blockquote>

<p>墨菲定律：如果可能出错，那么就一定会出错。所以对什么不要抱侥幸心理。</p>

<h4>10.1.3 暗示性承诺</h4>

<blockquote><p>专业开发人员能够清楚区分预估和承诺。只有在确切知道可以完成的前提下，他们才会给出承诺。此外，他们也会小心避免给出暗示性的承诺。他们会尽可能清楚地说明预估的概率分布，这样主管就可以做出合适的计划。</p></blockquote>

<h3>10.2 PERT</h3>

<blockquote><p>计划评审技术（PERT，Program Evaluation and Review Technique）。</p></blockquote>

<h3>10.3 预估任务</h3>

<blockquote><p>“德尔菲法”（wideband delphi）。</p>

<p>共识。</p>

<p>一组人集合起来，讨论某项任务，预估完成时间，然后重复“讨论－预估”的过程，直到意见统一。</p>

<ul>
<li><p>1.亮手指</p></li>
<li><p>2.规划扑克</p></li>
</ul>
</blockquote>

<p>之前用斐波那契数列实践过，预估过卡片的点数。</p>

<blockquote><ul>
<li>3.关联预估</li>
</ul>
</blockquote>

<p>将卡片打乱铺开，按照任务的复杂度排序。最后，静默的排序终止。开始讨论取得共识。在实践的过程中，从有分歧到达成一致，还挺有意思的。</p>

<blockquote><ul>
<li>4.三元预估</li>
</ul>
</blockquote>

<h3>10.4 大数定理</h3>

<blockquote><p>控制错误的办法之一是使用大数定律。该定律的意思是：把大任务分成许多小任务，分开预估再加总，结果会比单独评估大任务要准确很多。</p></blockquote>

<p>预估实践的比较少，个人觉得主要还是需要经验的积累。</p>

<h2>第十一章 压力</h2>

<blockquote><p>即使有压力，专业开发人员也会冷静果断。</p></blockquote>

<h3>11.1 避免压力</h3>

<blockquote><p>在压力下保持冷静的最好方式，便是规避会导致压力的处境。</p></blockquote>

<h4>11.1.1 承诺</h4>

<blockquote><p>应当避免对没有把握能够达成的最后期限作出承诺，这一点很重要。</p></blockquote>

<h4>11.1.2 保持整洁</h4>

<blockquote><p>快速前进确保最后期限的方法，便是保持整洁。</p>

<p>让系统、代码和设计尽可能整洁，就可以避免压力。</p>

<p>混乱会降低速度，导致工期延误，承诺失信。因此，要尽力保持输出成果整洁干净。</p></blockquote>

<h4>11.1.3 危机中的纪律</h4>

<blockquote><p>观察自己在危急时刻中的反应，就可以了解自己的信念。</p>

<p>选择那些你在危急时刻依然会遵循的纪律原则，并且在所有工作中都遵守这些纪律。</p></blockquote>

<h3>11.2 应对压力</h3>

<h4>11.2.1 不要惊慌失措</h4>

<h4>11.2.2 沟通</h4>

<blockquote><p>让你的团队和主管知道你正身陷困境之中。告诉他们你所制定的走出困境的最佳计划。请求他们的支援和指引。避免制造意外之外的诧异。</p></blockquote>

<h4>11.2.3 依靠你的纪律原则</h4>

<blockquote><p>战胜压力煎熬的唯一方法，便是依靠那些你已经知道切实有效的东西——你平时遵守的纪律。</p></blockquote>

<h4>11.2.4 寻求帮助</h4>

<blockquote><p>结对！</p></blockquote>

<h2>第十二章 协作</h2>

<h3>12.1 程序员与人</h3>

<blockquote><p>编程用的机器则整洁，行为也可预见。</p></blockquote>

<p>“我的Mac就是我的女朋友。”</p>

<h4>12.1.1 程序员与雇主</h4>

<blockquote><p>专业程序员的首要职责是满足雇主的需求。</p>

<p>深刻理解业务目标。</p></blockquote>

<h4>12.1.2 程序员与程序员</h4>

<blockquote><p>团队中每位成员都能签出任何模块的代码，做出任何他们认为合适的修改。</p>

<p>专业人士会结对工作。</p>

<p>因为至少对有些问题而言，结对是最有效的解决方法。</p>

<p>专业人士结对工作，因为这是分享知识的最好途径。</p>

<p>专业人士之所以结对，是因为结对是复查代码最好的方式。</p></blockquote>

<h3>12.2 小脑</h3>

<blockquote><p>有些时候，单独工作是正确的。</p>

<p>但是一般来说，和其他人紧密协作、在大部分时间段中结对工作，是最好的做法。</p></blockquote>

<h3>12.3 结论</h3>

<blockquote><p>编程就意味着与人协作。</p></blockquote>

<h2>第十三章 团队与项目</h2>

<h3>13.1 只是简单混合吗？</h3>

<blockquote><p>让一个程序员把一半的时间投入在项目A中，把其余时间投入在项目B中，这并不可行，尤其是当这两个项目的项目经理不同、业务分析师不同、程序员不同、测试人员不同时，更不可行。</p></blockquote>

<h4>13.1.1 有凝聚力的团队</h4>

<blockquote><p>这个团队应该配有程序员、测试人员和分析师，同时还要有一名项目经理。</p>

<p>其中有一名团队成员可能会拿出部分时间充任团队教练或Master的角色，负责确保项目进展，监督成员遵守纪律。</p></blockquote>

<p>类似Scrum敏捷项目管理框架中的Scrum Master。Scrum敏捷实践有接触过，有时间这里的知识要再巩固一下。</p>

<blockquote><p>专业的开发组织会把项目分配给已形成凝聚力的团队，而不会围绕着项目来组建团队。</p></blockquote>

<h4>13.1.2 如何管理有凝聚力的团队</h4>

<blockquote><p>每个团队都有自己的速度。团队的速度，即是指在一定时间段内团队能够完成的工作量。有些团队使用每周点数来衡量自己的速度，其中“点数”是一种关于复杂度的单位。</p>

<p>管理人员可以对分配给团队的项目设置一个目标值。</p></blockquote>

<h4>13.1.3 项目承包人的困境</h4>

<blockquote><p>项目承包人的职责所在，便是清晰地定义和陈述项目的价值和意义，让项目得到公司管理层的认可和支持。</p></blockquote>

<h2>第十四章 辅导、学徒期与技艺</h2>

<h3>14.1 失败的学位教育</h3>

<blockquote><p>那些符合要求的毕业生有个共同点：他们几乎都在进入大学之前就已经自学编程，并且在大学里依然保持自学的习惯。</p></blockquote>

<p>自学很重要，所以更要学会<a href="http://boxingp.github.io/blog/2015/01/29/the-modern-autodidact-reading-notes/">如何自学</a>。</p>

<h3>14.2 辅导</h3>

<h3>14.3 学徒期</h3>

<h4>14.3.1 软件学徒期</h4>

<blockquote><ul>
<li><p>1.大师</p></li>
<li><p>2.熟练工</p></li>
<li><p>3.学徒/实习生</p></li>
</ul>
</blockquote>

<h4>14.3.2 现实情况</h4>

<blockquote><p>我们今天的做法和我所提倡的理想化的学徒制程序，这两者之间的主要差异在于技术方面的传授、培训、督导和检查。</p></blockquote>

<h3>14.4 技艺</h3>

<blockquote><p>成熟工匠是一名专业人士。</p>

<p>技艺是工匠所持的精神状态。</p></blockquote>

<h2>附录 工具</h2>

<h3>A.2 源代码控制</h3>

<blockquote><p>开源工具通常是最好的选择。</p></blockquote>

<h4>A.2.2 悲观锁与乐观锁</h4>

<blockquote><p>永远不要签入没有通过全部测试的代码。永远不要。</p></blockquote>

<h4>A.2.3 CVS/SVN</h4>

<p><a href="http://git-scm.com/">Git</a>大法好！强烈建议未曾接触过Git的人开始使用Git对自己的软件版本进行管理。你会发现你打开了美好新世界的大门。</p>

<h3>A.3 集成开发环境/编辑器</h3>

<h4>A.3.1 vi</h4>

<p>使用过一段时间的VIM，个人觉得不求精通，但求掌握，毕竟在一些时候，用它可以快速编辑一些代码。如果花时间精通它之后，你会发现它和IDE工具一样好用。</p>

<h4>A.3.3 Eclipse/IntelliJ</h4>

<p>我现在用的是<a href="https://www.jetbrains.com/idea/">IntelliJ</a>。你可以更方便地编辑代码，效率当然可以得到很大的提高。对于个人来说，如果不想购买License的话，有社区版可供使用。</p>

<h3>A.4 问题跟踪</h3>

<blockquote><p>有时候，最好用的问题跟踪系统可能是一打卡片和一个公告板。</p></blockquote>

<p>在工作中使用的是<a href="http://leankit.com/">LeanKit</a>，个人使用更多的是<a href="https://trello.com/">Trello</a>。创建多栏，在合适的时候把卡片从一栏移到下一栏。</p>

<h3>A.5 持续构建</h3>

<blockquote><p>我的持续构建哲学很简单：把它和源代码控制系统对接起来。不管什么时候，只要有人签入代码，就要能自动进行构建，并把结果状态报告给团队。</p>

<p>团队必须一直确保构建成功。</p></blockquote>

<p>我目前接触过的是<a href="https://www.atlassian.com/software/bamboo">Bamboo</a>。</p>

<h3>A.6 单元测试工具</h3>

<blockquote><p>不论选择什么样的单元测试工具，这些工具都要支持如下一些基本的特性。</p>

<ul>
<li><p>(1)必须能够快速便捷的运行测试。</p></li>
<li><p>(2)对于测试是通过还是失败了，这些工具应该给出清楚的视觉提示。</p></li>
<li><p>(3)对于测试进度，这些工具也应该给出清楚的视觉提示。</p></li>
<li><p>(4)这些工具应该避免测试用例之间彼此通信。</p></li>
<li><p>(5)这些工具应该使编写测试变得十分容易。</p></li>
</ul>
</blockquote>

<p>现在我用的更多的是写Java时的<a href="http://junit.org/">JUnit</a>。</p>

<h3>A.7 组件测试工具</h3>

<blockquote><p>这些工具用于在API层对组件进行测试。它们的任务是要确保组件行为是以业务人员和QA能够理解的语言来描述的。</p></blockquote>

<p>我目前接触过的是<a href="https://cukes.info/">cucumber</a>，有时间需要好好实践一下。</p>

<h3>A.9 UML/MDA</h3>

<h4>A.9.1 细节</h4>

<blockquote><p>程序员负责管理各种细节，这是我们的职责。我们通过管理各种最微小的细节来规范系统的行为。</p></blockquote>

<p>整本书读下来，收获不小。之前很多在工作中接触过的方法或实践，并不是很清楚它们的理论或原理。读着读着很多时候发现，原来之前实践的方法叫这个名字。可以方便以后对实践进行更新或是更好的进一步思考。方法论的书，常读常新，把自己的实践和理论结合起来，防止走弯路的同时，也构建起了自己的理论体系。本书提到的很多实践，发现在ThoughtWorks的工作中都接触到了。感谢在TW的成长。</p>

<p><img class="left" src="/images/2015/the-clean-coder.jpg" width="98" height="137"></p>

<p><a href="http://book.douban.com/subject/11614538/">程序员的职业素养</a> - <a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">Robert C. Martin</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《我们要自学》读书笔记]]></title>
    <link href="http://boxingp.github.io/blog/2015/01/29/the-modern-autodidact-reading-notes/"/>
    <updated>2015-01-29T20:00:22+08:00</updated>
    <id>http://boxingp.github.io/blog/2015/01/29/the-modern-autodidact-reading-notes</id>
    <content type="html"><![CDATA[<p>有人推荐《我们要自学》这本书给我，花了几个小时把它看完，做了摘录。在知道些理论后更多的是要实践，再结合自己的特点，更好更有效率地自学。</p>

<!-- more -->


<hr />

<h1>第1章　为什么要自学</h1>

<h2>1.1　什么是自学</h2>

<blockquote><p>自学就是完全自发、自主地进行学习。</p>

<p>自学和教学最大的不同，在于有没有终极目标。</p></blockquote>

<p>之前自己很多时候不知道学那些知识有什么用，后来发现，过一段时间总会不经意间用到，功不唐捐。自学觉得就是让自己不会被落下，不断更新自己的知识。</p>

<h2>1.2　自学让人自由</h2>

<blockquote><p>对于自由的向往和追求，一直推动着我的学习。</p>

<p>除了知识带给人冲破蒙昧的自由感之外，还有自主学习带来的一切自己掌握的自由感。</p></blockquote>

<h2>1.3　自学让人快乐</h2>

<blockquote><p>而自学正是寻求人生目标和意义的最佳渠道。</p>

<p>这些都可以看作是对人生目标和意义的有益探索。这样的探索让人们不再臣服于自己的原始本能，享受到真正的快乐。</p></blockquote>

<p>自己一晚上看资料学会视频剪辑，剪出来的片子能触动别人，这件事让我感受很深也很开心。</p>

<h1>第2章　自学是否可能</h1>

<blockquote><p>告诉我的，我会忘记；教给我的，我只能记住；让我参与，我才能学会。</p>

<p>本杰明•富兰克林</p></blockquote>

<h2>2.1　没有普适</h2>

<blockquote><p>在我看来，这是因为根本就没有普遍适用的学习方法，只有最适合自己的方法。要找到适合自己的方法，就必须要对自己有深刻的了解。</p></blockquote>

<p>在了解自己的基础上，要正视自己的不足。</p>

<h2>2.2　知识守恒</h2>

<blockquote><p>也就是说，如果单纯靠传授，老师不可能教出比自己更优秀的学生。</p>

<p>迷信老师，或者完全拒绝老师，都不是理性的学习态度。</p></blockquote>

<p>很多时候，自己解决不了的问题，请教人，会因为三两句话瞬间得到解决。</p>

<h2>2.3　著名的自学者</h2>

<blockquote><p>达•芬奇
本杰明•富兰克林
托马斯•爱迪生
安藤忠雄
李宗盛，罗大佑，陈升
韩寒，东野圭吾</p>

<p>学习是没有止境的，但是学校生活总会结束。</p></blockquote>

<p>之前总会遇见有人说，等毕业了就不用学了，真是太天真和无知了。</p>

<h1>第3章　自学与老师</h1>

<blockquote><p>作为一个现代人，我们有各种各样的科技手段来帮助我们学习，弥补老师的缺失，或者取代老师的部分职能，让我们更容易形成适合自己的学习方法。</p></blockquote>

<h2>3.1　教学的本质</h2>

<blockquote><p>在我看来，虽然教学看上去像是在传输知识和经验，但究其本质，乃是人为地引导和辅助自学。</p></blockquote>

<h2>3.2　老师的作用</h2>

<h3>3.2.1　制订计划</h3>

<blockquote><p>一般来说，计划包括三个元素：起点，路线图和目标。</p>

<p>学习是一个动态的过程，是一个不断反思和调整的过程。目标，步骤，都不是固定的，而是不断演进的。</p></blockquote>

<h3>3.2.2　进度监测</h3>

<blockquote><p>心流指的是人们全情投入一件事情，注意力极度集中，并产生持续愉悦感的心理状态。</p>

<p>要进入心流状态，人就必须满足以下七个条件：</p>

<p>（1）知道要做什么事</p>

<p>（2）知道怎么来做</p>

<p>（3）知道自己的进度</p>

<p>（4）知道下一步该怎么走</p>

<p>（5）认为事情的挑战很大</p>

<p>（6）相信自己的能力足够</p>

<p>（7）不被干扰的自由</p>

<p>对于自学者来说，第一条是目标，第二条是方法，第三条是监控进度，第四条是制订和跟随计划，五、六条是自己的心理，第七条则是学习的环境。</p>

<p>好的进度指标应该是量化的。</p>

<p>把自己的学习过程可视化，展示出来，让自己能随时看到自己的整体进度和完成情况。</p></blockquote>

<p>觉得可视化能更好的查看进度的实施。这和网上支付更容易消费更多很像。</p>

<h3>3.2.3　持续反馈</h3>

<blockquote><p>第一，你得能客观地判断和看待学习的情况。</p>

<p>我们要尽量把学习的情况纪录下来，然后客观地来看。</p>

<p>第二，你必须要有一个判断标准。</p>

<p>除了不断尝试之外，还有一个较为容易入手的办法，那就是把标准量化。</p>

<p>第三，反馈必须是可执行的。</p>

<p>没有具体指出问题的点，也没有给出具体的改进措施。</p></blockquote>

<p>在问别人要feedback时最容易遇到这一点，所以尽可能让对方给出详细的反馈。</p>

<h3>3.2.4　心得技巧</h3>

<blockquote><p>心得技巧分为两种，一种是知识和经验，另一种则主要针对学习方法。</p>

<p>记录下你的心得技巧</p></blockquote>

<h3>3.2.5　示之以范</h3>

<blockquote><p>自学者可以试着组成学习小组，相互示范自己的心得。如有需要，也可以找一位老师进行示范。</p></blockquote>

<p>有时候示范会一点就通。</p>

<h3>3.2.6　理念传输</h3>

<blockquote><p>老师的所有能力中，有一项是无可替代的，那就是启蒙，或者理念的传输。</p></blockquote>

<p>“师者，所以传道受业解惑也。”</p>

<h2>3.3　如何评判老师好坏</h2>

<blockquote><p>评判老师的好坏，在大多数情况下是在评判这位老师适不适合自己。</p></blockquote>

<h3>3.3.1　教育和利益</h3>

<blockquote><p>优秀的老师应该是教育的归教育，利益的归利益。</p></blockquote>

<p>现在很多时候是把教育更多地当作挣钱的一种手段。</p>

<h3>3.3.2　因材施教</h3>

<blockquote><p>优秀的老师应该能全面了解学生的背景以及学生对于学习的诉求，并不断调整自己的教学方式，以更好地达到教学效果。</p></blockquote>

<h3>3.3.3　训练师和老师</h3>

<blockquote><p>优秀的老师并不会以权威来压制学生，会允许学生提出自己的思考，并会很愿意跟学生进行讨论。</p></blockquote>

<h1>第4章　自学的方法</h1>

<h2>4.1　从哪里开始</h2>

<h3>4.1.1　你的目标是什么</h3>

<blockquote><p>在做任何事情之前，都应该明确目标是什么。</p>

<p>人在主动想要学习一个东西的时候，基本上都会有一个长期目标。虽然这个目标不一定清晰或者现实，但毕竟有一个。为了更好地确定学习的方向和路线，我们需要把这个长期目标尽量地细化。</p>

<p>在这个阶段，只需有一个大体的感觉即可，不必过于详细，也不用怕出错。</p></blockquote>

<h3>4.1.2　寻找入门级的材料</h3>

<blockquote><p>在海量的材料中探寻、收集、整理并吸收是一件很美好的事情，也是学习的一部分，所以，纵然很花时间，还请大家一定怀着积极的心态来做这个事情。</p></blockquote>

<p>搜索能力也是个人素质的一点。</p>

<h3>4.1.3　先上车再补票</h3>

<blockquote><p>从最简单，最直观的东西做起，不管做的再差，你总有可以自我反馈的基础。</p></blockquote>

<p>坏的实现总好过好的想法。</p>

<h3>4.1.4　快速建立信心</h3>

<blockquote><p>这样能迅速让人尝到的“甜头”（或者我们叫它quick-win）可以帮助我们在进一步深入学习前建立起信息，而信心可以帮助我们在长时间的学习过程中始终保持动力。</p>

<p>深入的学习必然会有一些看似枯燥的练习，也需要强大的毅力来坚持。这些必要的刻苦过程，任何方法论都无法代替。</p></blockquote>

<p>一定要坚持。而且正负反馈要平衡。</p>

<h2>4.2　寻找学习资源</h2>

<h3>4.2.1　书籍和文章</h3>

<blockquote><p>阅读大量的书籍可以让各种知识体系形成交叉，更容易触类旁通。阅读量大到一定程度，就容易促成质变，让人的整体思维模式和学习方法提升一个台阶。</p>

<p>读太多书反而变蠢的原因有两个：无差别阅读导致的浪费时间，以及尽信书导致没有自己的思考。</p>

<p>《如何阅读一本书》讲述了分层阅读法。把一本书分成骨头、血肉和灵魂三个层次。</p>

<p>－ 骨头就是它的整体目录，读者通过它可以快速浏览，搞明白这本书到底写的什么，然后用一句话把它总结出来，这是检视阅读。</p>

<p>－ 血肉就是把整本书的逻辑结构和论点、论据有机地组织和支撑起来，形成一个完整地架构，这是分析阅读。</p>

<p>－ 灵魂则是这本书的主题，读者通过把多个同样主题地书结合起来阅读，以形成一套兼容并包的知识体系，就是主题阅读。</p>

<p>对于提供新信息的书，采用从骨到肉地读法；对于确认已知信息的书，找出不同地论点；对于不同观点的书，集中对比阅读。</p>

<p>随时保持批判性思维，并在阅读不同书籍的时候使用不同的策略，可以让阅读更加高效，更有价值。</p>

<p>在阅读文章的时候，最好抱着明确的目的来阅读，通过搜索引擎来搜索和寻找。</p></blockquote>

<h3>4.2.2　多媒体资源</h3>

<h3>4.2.3　在线课程</h3>

<blockquote><p>Coursera，iversity，Udemy，KhanAcademy，公开课，TED</p></blockquote>

<h3>4.2.4　新型工具</h3>

<blockquote><p>游戏式的工具比较适合入门，但在一段时间之后，还是需要回归更加严肃一些的学习方式。</p></blockquote>

<h3>4.2.5　理性看待入门级材料</h3>

<blockquote><p>第一个问题是：读者是谁？</p>

<p>第二个问题是：目标是什么？</p></blockquote>

<h3>4.2.6　学习资源的局限性</h3>

<blockquote><p>学习资源的局限性就在此，它提供的是基本的知识，是看得见的东西。要学到东西，还有很多隐式知识，需要时间的积累和自己深度的思考。</p></blockquote>

<h2>4.3　制订学习计划</h2>

<h3>4.3.1　明确你的目标</h3>

<blockquote><p>我的学习计划包括一个长期目标、一个中期目标，以及一系列短期目标。</p>

<p>长期目标应该是半年到一年期的目标。长期目标应该比较具体。需要明确的是，我们不是在制定详尽的学习计划，我们只是在我们的学习生涯中标注出一个个的参照点。</p>

<p>中期目标，或者阶段目标，是对长期目标的切割。我一般把中期目标设定为一个月。</p>

<p>有了中期目标，实施一段时间之后，我们就能对长期目标的可行性作出判断。</p>

<p>短期目标就是每天都想要达到的目标，所谓的“速效目标”。我们应该尽量把它量化。短期目标的目的是让我们坚持。</p></blockquote>

<p>之前制定长期计划时容易比较抽象，而且做一做的容易变成一个很详尽的计划，导致可实施性降低。</p>

<h3>4.3.2　串成时间线</h3>

<blockquote><p>精益生产法（或者叫丰田生产法）。以结构化的形式公开展示信息以帮助某种流程的方法，看板。</p></blockquote>

<p>看板有时间要好好看看。两本书，<a href="http://book.douban.com/subject/5248909/">《金矿》</a><a href="http://book.douban.com/subject/25788807/">《看板方法》</a>。</p>

<h3>4.3.3　调整学习方法</h3>

<blockquote><p>第一，你学得快不快乐；第二，你学得快不快。</p></blockquote>

<p>自己有时学习方法调整的不是很好，需要改进。</p>

<blockquote><p>全力以赴，穷则思变。</p></blockquote>

<h2>4.4　练习的方法</h2>

<h3>4.4.1　隔离薄弱点</h3>

<blockquote><p>学习就是用重复练习来找到方法，形成习惯。薄弱点和比较好的部分混在一起，就是在浪费时间，因为薄弱点的重复变少了，而比较好的部分其实又不必重复。</p></blockquote>

<h3>4.4.2　抓整体，放细节</h3>

<blockquote><p>注重整体效果，而不要被细节所困扰，打断自己的心流，浪费时间。</p></blockquote>

<h3>4.4.3　练后提升</h3>

<blockquote><p>想要保持良好的练习效应，我们就必须然大脑和肌肉充分休息。</p></blockquote>

<h3>4.4.4　脑内练习</h3>

<blockquote><p>任何需要思考的练习，都可以使用脑内练习的方式。</p></blockquote>

<h3>4.4.5　形成知识体系</h3>

<blockquote><p>知识体系的形成靠的是把知识外部化。</p>

<p>公开演讲。</p>

<p>工作坊。</p>

<p>写作。</p></blockquote>

<p>写作驱动开发。</p>

<h3>4.4.6　镜面法和锚点</h3>

<blockquote><p>两种很有趣的大脑锻炼法，一种锻炼我们的初心，一种锻炼我们的观察能力。</p></blockquote>

<h1>第5章　自学的难点</h1>

<h2>5.1　拖延症的问题</h2>

<blockquote><p>人喜欢拖延工作的原因常常是：一、工作不够细分，过程展示不够清晰；二、截至日期还早。</p>

<p>对于自学者来说，</p>

<p>第一，是对要学的东西没有爱。</p>

<p>第二，是没有紧迫感。</p>

<p>第三，是不能坚持。</p>

<p>第四，是无法开始。</p>

<p>第五，是完美主义。这里指的完美主义者有三个特点，第一是准备工作一定要做足，第二是方法方式一定要用对，第三是一犯错误就沮丧。</p>

<p>第六，是并行失误太多。</p>

<p>最后，是时机未到。</p></blockquote>

<h2>5.2　窍门的问题</h2>

<blockquote><p>第一重意义就是我们所知道的，特别适合自己的学习方法或者技巧。第二重意义则是通过长时间练习而养成的习惯和娴熟。</p></blockquote>

<h2>5.3　不切实际的希望</h2>

<blockquote><p>在设定目标和期望值的时候，一定要恰当。</p></blockquote>

<h2>5.4　驱动和推动</h2>

<blockquote><p>推动力有其特定的适用场景和作用，不过，驱动的力量才是长效的力量。</p></blockquote>

<h2>5.5　整理和收纳</h2>

<blockquote><p>第一，不要同时做太多的事情；第二，把所有信息整理起来，并且形成整理的习惯。</p></blockquote>

<p>一件一件的把事情做好。</p>

<h2>5.6　回归主流社会</h2>

<blockquote><p>一个真正优秀的自学者是不惧怕学校摧残的。</p></blockquote>

<p>原来经常听到这句话，带着镣铐跳舞也要跳的好看。</p>

<h1>第6章　自学的例子</h1>

<h2>6.1　学习英语</h2>

<h3>6.1.1　启蒙期</h3>

<h3>6.1.2　维持期</h3>

<h3>6.1.3　发展期</h3>

<h3>6.1.4　总结</h3>

<h2>6.2　学习画画</h2>

<h3>6.2.1　用初心来画准</h3>

<h3>6.2.2　用艺眼来画好</h3>

<h3>6.2.3　用想象来 创作</h3>

<h3>6.2.4　总结</h3>

<h3>6.2.5　书籍推荐</h3>

<h2>6.3　学习钢琴</h2>

<h3>6.3.1　从GarageBand 开始</h3>

<h3>6.3.2　方法和乐理充电</h3>

<h3>6.3.3　用《月光奏鸣曲》尝甜头</h3>

<h3>6.3.4　继续深入《D 大调进行曲》</h3>

<h3>6.3.5　总结</h3>

<h3>6.3.6　活用资源</h3>

<h3>6.3.7　书籍推荐</h3>

<p>总的来说，自己了解到不少方法，也找到一些自己的不好的实践，还是书里的那句，结合自身的情况发展出适合自己的自学方法。</p>

<p><font style="background-color: black">自学大法好！</font></p>

<p><img class="left" src="/images/2015/the-modern-autodidact.jpg" width="102" height="145"></p>

<p><a href="http://book.douban.com/subject/26270774/">我们要自学</a> - 张玳</p>
]]></content>
  </entry>
  
</feed>
