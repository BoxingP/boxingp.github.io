---
layout: post
title: "《敏捷软件开发：原则、模式与实践》读书笔记"
date: 2015-02-27 22:05:42 +0800
comments: true
categories:
- Book
- Note
---

发现自己对于Java的一些设计以及实践了解得不够，导致写出来的代码存在着问题，同时也想要和其他人很好地交流自己的设计思路。今天终于摸出了这本书，好好读一下，同时写代码实践，希望会有提高。

<!-- more -->

第二本Bob大叔的书。

##前言

>敏捷开发（Agile Development）

>极限编程（eXtreme Programming，简称XP）

#第I部分 敏捷开发

##第1章 敏捷实践

概括出如何让软件开发团队具有快速工作、响应变化能力的价值观（value）。也就是敏捷联盟宣言。瞄了一眼名单，看到了Martin Fowler，[他的网站](http://martinfowler.com/)有不少干货。

>1. 个体和交互胜过过程和工具

>2. 可以工作的软件胜过面面俱到的文档

>3. 客户合作胜过合同谈判

>4. 响应变化胜过遵循计划

于是引出了12条原则

>1. 我们最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意。

持续交付。

>2. 即使到了开发的后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势。

保持软件结构的灵活性。

>3. 经常性地交付可以工作的软件，交付的间隔可以从几周到几个月，交付的时间间隔越短越好。

快速迭代。

>4. 在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。

>5. 围绕被激励起来的个人来构建项目。给他们提供所需要的环境和支持，并且信任他们能够完成工作。

>6. 在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈。

>7. 工作的软件是首要的进度度量标准。

我的理解是要明确好真正的目标是什么。

>8. 敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度。

还是那句话，敏捷项目是马拉松长跑。

>9. 不断地关注优秀的技能和好的设计会增强敏捷能力。

>10. 简单——使未完成的工作最大化的艺术——是根本的。

我觉得TDD的好处就是可以避免开发的过程中想太多导致范围超出预期。

>11. 最好的构架、需求和设计出自于自组织的团队。

敏捷团队的成员共同来解决项目中所有方面的问题。

>12. 每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。

隔一段时间进行一下Retro。

##第2章 极限编程概述

>极限编程（eXtreme Programming，简称XP）是敏捷方法中最著名的一个。它由一系列简单却互相依赖的实践组成。

>1.客户作为团队成员

>XP团队中的客户是指定义产品的特性并排列这些特性优先级的人或者团队。

>2.用户素材

>在XP中，我们和客户反复讨论，以获取对于需求细节的理解，但是不去捕获那些细节。

>用户素材（user stories）就是正在进行的关于需求谈话的助记符。

>3.短交付周期

>3.1迭代计划

>它由客户根据开发人员确定的预算而选择的一些用户素材组成。

>3.2发布计划

>它表示了一次较大的交付，通常此次交付会被加入到产品中。

>4.验收测试

>5.结对编程

>6.测试驱动的开发方法

>7.集体所有权

>结对编程中的每一对都具有拆出（check out）任何模块并对它进行改进的权利。

>8.持续集成

>9.可持续的开发速度

>10.开放的工作空间

>11.计划游戏

>计划游戏（planning game）的本质是划分业务人员和开发人员之间的职责。业务人员（也就是客户）决定特性（feature）的重要性，开发人员决定实现一个特性所花费的代价。

>在每次发布和每次迭代的开始，开发人员基于在最近一次迭代或者最近一次发布中他们所完成的工作量，为客户提供一个预算。客户选择那些所需的成本合计起来不超过该预算的用户素材。

>12.简单的设计

>12.1考虑能够工作的最简单的事情

>12.2你将不需要它

>他们开始时假设将不需要那些基础结构。

>12.3一次，并且只有一次

>极限编程者不能容忍重复的代码。

>13.重构

>14.隐喻

>它是将整个系统联系在一起的全局视图：它是系统的未来景象，是它使得所有单独模块的位置和外观（shape）变得明显直观。如果模块的外观与整个系统的隐喻不符，那么你就知道该模块是错误的。

>隐喻通常可以归纳为一个名字系统。这些名字提供了一个系统组成元素的词汇表，并且有助于定义它们之间关系。

##第3章 计划

这章是对XP中计划游戏的描述。

>1.初始探索

>在项目开始时，开发人员和客户会尽量确定出所有真正重要的用户素材。

>素材的编写会一直持续到项目完成。

>开发人员共同对这些素材进行估算。估算是相对的，不是绝对的。

>**探究、分解和速度**

>对一个用户素材进行分解或者合并的主要原因，是为了使其大小适于被准确地估算。

>为了知道用户素材的绝对大小，需要一个称为速度（velocity）的因子。

>通常，花费几天时间去原型化一到两个用户素材来了解团队的速度就足够了。这样的一个原型化过程称为探究（spike）。

>2.发布计划

>客户挑选在该发布中她们想要实现的素材，并大致确定这些素材的实现顺序。客户不能选择与当前开发速度不符的更多的素材。

>3.迭代计划

>4.任务计划

>开发人员把素材分解成开发任务，一个任务就是一个开发人员能够在4～16小时之内实现的一些功能。

>**迭代的中点**

>在这个时间点上，本次迭代中所安排的半数素材应该被完成。如果没有完成，那么团队会设法重新分配没有完成的任务和职责，以保证在迭代结束时能够完成所有的素材。

>5.迭代

>每两周，本次迭代结束，下次迭代开始。在每次迭代结束时，会给客户演示当前可运行的程序。要求客户对项目程序的外观、感觉和性能进行评价。客户会以新的用户素材的方式提供反馈。

#第4章 测试

>1.测试驱动的开发方法。

>程序中的每一项功能都有测试来验证它的操作的正确性。

>首先编写测试可以迫使我们使用不同的观察点。

>通过首先编写测试，我们就迫使自己把程序设计为可测试的。

>首先编写测试的另一个重要效果，是测试可以作为一种无价的文档形式。

>有意图的编程（intentional programming）。在实现之前，先在测试中陈述你的意图，使你的意图尽可能地简单、易读。你相信这种简单和清楚会给程序指出一个好的结构。

>在编写产品代码之前，先编写测试常常会暴露程序中应该被解耦合的区域。¡¡

>为了测试而对模块进行隔离的需要，迫使我们以对整个程序结构都有益的方式对程序进行解耦合。

>2.验收测试

>作为验证工具来说，单元测试是必要的，但是不够充分。单元测试用来验证系统的小的组成单元应该按照所期望的方式工作，但是它们没有验证系统作为一个整体时工作的正确性。单元测试是用来验证系统中个别机制的白盒测试（white-box tests）。验收测试是用来验证系统满足客户需求的黑盒测试（black-box tests）。

>验收测试由不了解系统内部机制的人编写。客户可以直接或者和一些技术人员（可能是QA人员）一起来编写验收测试。验收测试是程序，因此是可以运行的。然而，通常使用专为应用程序的客户创建的脚本语言来编写验收测试。

>验收测试是关于一项特性（feature）的最终的文档。

>此外，首先编写验收测试的行为对于系统的构架方面具有深远的影响。

>3.结论

>测试套件运行起来越简单，就会越频繁地运行它们。测试运行得越多，就会越快地发现和那些测试的任何背离。

>单元测试和验收测试都是一种文档形式，那样的文档是可以编译和执行的；因此，它是准确和可靠的。此外，编写测试所使用的语言是明确的，并且它们的观看者使这些语言非常易读。

>测试最重要的好处就是它对于构架和设计的影响。

##第5章 重构

>在Martin Fowler的名著《重构》一书中，他把重构（Refactoring）定义为：“……在不改变代码外在行为的前提下对代码做出修改，以改进代码的内部结构的过程。”

>每一个软件模块都具有三项职责。第一个职责是它运行起来所完成的功能。……第二个职责是它要应对变化。……第三个职责是要和阅读它的人进行沟通。

>重构的目的，正像在本章中描述的，是为了每天清洁你的代码。

##第6章 一次编程实践

>图示有时是不需要的。何时不需要呢？在创建了它们而没有验证它们的代码就打算去遵循它们时，图示就是无意的。画一幅图来探究一个想法是没有错的。然而，画一幅图后，不应该假定该图就是相关任务的最好设计。你会发现最好的设计是在你首先编写测试，一小步一小步前进时逐渐形成的。

形象地展现了结对编程、TDD以及重构的过程。

多一句嘴，之前一直在诺基亚手机上玩bowling的游戏，看完这章知道它的记分规则了。

#第II部分 敏捷设计

>在每次迭代中，团队改进系统设计，使设计尽可能适合于当前系统。团队不会花费许多时间去预测未来的需求和需要，也不会试图在今天就构建一些基础结构去支撑那些他们认为明天才会需要的特性。他们更愿意关注当前的系统结构，并使它尽可能地好。

>**拙劣设计的症状**

>- 僵化性（Rigidity）

>- 脆弱性（Fragility）

>- 牢固性（Immobility）

>- 粘滞性（Viscosity）

>- 不必要的复杂性（Needless Complexity）

>- 不必要的重复（Needless Repetition）

>- 晦涩性（Opacity）

>**原则**

>- 单一职责原则（The Single Responsibility Principle，简称SRP）

>- 开放-封闭原则（The Open-Close Principle，简称OCP）

>- Liskov替换原则（The Liskov Substitution Principle，简称LSP）

>- 依赖倒置原则（The Dependency Inversion Principle，简称DIP）

>- 接口隔离原则（The Interface Segregation Principle，简称ISP）

这就是面向对象设计中所说的[SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29)。

##第7章 什么是敏捷设计

>软件项目的设计是一个抽象的概念。它和程序的概括形状（shape）、结构以及每一个模块、类和方法的详细形状和结构有关。可以使用许多不同的媒介（media）去描绘它，但是它最终体现为源代码。最后，源代码就是设计。

>当软件出现下面任何一种气味时，就表明软件正在腐化。

>1.僵化性（Rigidity）

>僵化性是指难以对软件进行改动，即使是简单的改动。如果单一的改动会导致有依赖关系的模块中的连锁改动，那么设计就是僵化的。必须要改动的模块越多，设计就越僵化。

>2.脆弱性（Fragility）

>脆弱性是指，在进行一个改动时，程序的许多地方就可能出现问题。

>3.牢固性（Immobility）

>牢固性是指，设计中包含了对其他系统有用的部分，但是要把这些部分从系统中分离出来所需要的努力和风险是巨大的。

>4.粘滞性（Viscosity）

>粘滞性有两种表现形式：软件的粘滞性和环境的粘滞性。

>当面临一个改动时，开发人员常常发现会有多种改动的方法。其中，一些方法会保持设计：而另外一些会破坏设计（也就是生硬的手法）。当那些可以保持系统设计的方法比那些生硬手法更难应用时，就表明设计具有高的粘滞性。做错误的事情是容易的，但是做正确的事情却很难。

>当开发环境迟钝、低效时，就会产生环境的粘滞性。

>5.不必要的复杂性（Needless Complexity）

>如果设计中包含有当前没有用的组成部分，它就含有不必要的复杂性。

>6.不必要的重复（Needless Repetition）

>当同样的代码以稍微不同的形式一再出现时，就表示开发人员忽视了抽象。

>7.晦涩性（Opacity）

>晦涩性是指模块难以理解。

>在非敏捷环境中，由于需求没有按照初始设计预见的方式进行变化，从而导致了设计的退化。

>设计必须要保持干净、简单，并且由于源代码是设计最重要的表示，所以它同样要保持干净。

>敏捷设计是一个过程，不是一个事件。它是一个持续的应用原则、模式以及实践来改进软件的结构和可读性的过程。它致力于保持系统设计在任何时间都尽可能的简单、干净以及富有表现力。

（先挖坑，马上填）

{% img left /images/2015/agile-software-development.jpg 98 137 %}

[敏捷软件开发：原则、模式与实践](http://book.douban.com/subject/1140457/) - [Robert C. Martin](http://en.wikipedia.org/wiki/Robert_Cecil_Martin)
